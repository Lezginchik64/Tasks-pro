# == Потоковый ввод stdin и вывод stdout ==

# == Потоковый ввод ==
# Поток ввода (sys.stdin) — это специальный объект в программе, куда попадает весь текст, который ввел пользователь.
# Потоком его называют потому, что данные хранятся в нем до тех пор, пока программа их не прочитала.
# Таким образом, данные поступают в программу и временно сохраняются в потоке ввода (sys.stdin), а программа может забрать их оттуда, например, с помощью встроенной функции input().
# В момент прочтения данные пропадают из потока ввода, так как он хранит их до тех пор, пока они не будут прочитаны.

# Поток ввода (sys.stdin) является итератором, который невозможно перезапустить.
# Как и любой итератор, он может двигаться только вперед. Как только данные прочитаны, они удаляются из потока ввода безвозвратно.

# Элементы, которые выдает этот итератор, — это строки, введенные пользователем. Если пользовательский ввод закончен, то итератор прекращает работу.
# Пока пользователь не ввел последнюю строку, мы не знаем, сколько элементов в итераторе.

# Напишем программу, которая дублирует каждую введенную пользователем строку.
import sys

for line in sys.stdin:
    print(line.strip('\n'))
# Строковый метод strip('\n') отрезает от строки line символ перевода строки, поскольку функция print сама переводит строку.
# Пока есть данные в потоке ввода sys.stdin (то есть пока пользователь их вводит), программа будет записывать вводимые строки в переменную line, убирать символы перевода строки и выводить их на печать.

# Если запустить такую программу, то она будет работать вечно.
# Чтобы показать, что ввод закончен, недостаточно нажать Enter — компьютер не знает, завершил ли пользователь работу или будет еще что-то вводить (при этом Enter превратится в пустую строку).
# Для завершения ввода необходимо ввести Ctrl + D (если работаете в консоли Linux или IDE PyCharm), либо Ctrl + Z, затем Enter (если работаете в консоли Windows).




# == Читаем входные данные в одну строку ==
# С помощью потока ввода (sys.stdin) можно в одну строчку кода прочитать весь пользовательский ввод в список.
data = [i.strip() for i in sys.stdin]
d = list(map(str.strip, sys.stdin))
# Обратите внимание, что мы ничего не знаем о количестве введенных строк. Раньше приходилось в задачах сначала указывать количество строк, а уже затем сами строки.
# Если мы не знаем, в какой момент надо прекратить ввод, то воспользоваться функцией input() не удастся. В таких случаях остается только работать с потоковым вводом (sys.stdin).



# == Методы read() и readlines() ==
# Как уже было сказано выше, мы можем обойти циклом for итератор sys.stdin.
# Кроме того, можно считать все строки из итератора (с сохранением символов перевода строки) в список с помощью метода readlines():
import sys

data = sys.stdin.readlines()    # ['asdas\n', 'asdas\n', 'd\n']
# Обратите внимание на то, что символ перехода на новую строку (\n) сохраняется в считанных строках.
# Если разделять на строки нет необходимости, то считать многострочный текст из стандартного потока ввода в текстовую переменную можно с помощью метода read():
data = sys.stdin.read()




# == Потоковый вывод ==
# Аналогичным образом можно работать с потоковым выводом (sys.stdout).
# По умолчанию функция print() перенаправляет вывод данных именно в sys.stdout, хотя нам ничего не мешает самостоятельно писать в него.
import sys

print('Hello')
sys.stdout.write('world!')
print('from')
sys.stdout.write('python\n')
print('Bye-bye')
# Hello
# world!from
# python
# Bye-bye
# Обратите внимание на то, что функция print() добавляет перевод на новую строку, а явная запись данных в sys.stdout с помощью метода write() — нет.
# Чтобы добавить перевод на новую строку, мы используем стандартный символ \n.

# Также нужно иметь в виду, что при использовании потока вывода sys.stdout нам нужно самостоятельно преобразовывать данные к строковому типу данных (функция print() это делает автоматически).
import sys

sys.stdout.write(str(17))     # преобразуем данные в строку



# == Примечания ==
# Примечание 1. По умолчанию функция input() читает данные из потока ввода sys.stdin, а функция print() печатает данные в поток вывода sys.stdout.

# Примечание 2. Функция print() — это удобная обертка (wrapper) вокруг метода sys.stdout.write().
# Функцию input() часто можно рассматривать как обертку (wrapper) вокруг sys.stdin.readline().

# Примечание 3. Объекты sys.stdin и sys.stdout являются файловыми объектами, предоставляемыми ОС.
# Им доступны все соответствующие методы (read(), readline(), readlines(), write(), writelines()).
# В общем случае, когда программа запускается в интерактивном сеансе, stdin является клавиатурным вводом,
# а stdout является выводом на экран, но оболочка может использоваться для перенаправления из обычных файлов или вывода на канал и ввода в другие программы.
import sys

temp = sys.stdout                         # сохраняем исходный потоковый вывод
sys.stdout = open('log.txt', 'w')         # перенаправляем потоковый вывод в файл
print('testing123')
print('another line')
sys.stdout.close()
sys.stdout = temp                         # восстанавливаем исходный потоковый вывод
print('back to normal')
# приведет к созданию текстового файла log.txt, содержащего следующее:
# testing123
# another line

# Разбор кода:
# В переменной temp сохраняем исходный потоковый вывод, так как дальше мы его переопределим по другому
# Собственно, переопределяем потоковый вывод на открытие файла для записи
# print() для вывода использует потоковый sys.stdout, но так как мы его ранее переопределили, то это уже будет не вывод на экран, а запись строки в файл
# тоже самое, запись ещё одной строки в файл
# закрытие файла
# восстанавливаем исходный потоковый вывод из переменной temp
# теперь print() снова будет выводить текст на экран, и эту строку уже не будет записывать в файл

# Функция print() использует потоковый вывод sys.stdout для вывода информации.
# По умолчанию происходит вывод на экран. Если переопределить потоковый вывод и присвоить ему объект файла, например, как в этом примере, то и запись будет осуществляться в файл.
# То есть для того, чтобы изменить поведение функции print(), нужно переопределить sys.stdout.
# P.S. Кстати, такого же поведения можно добиться, не переопределяя потоковый вывод явно.
# У функции print() есть необязательный аргумент file, который можно использовать для записи в файл, например, вот так:
f = open('pygen.txt', 'w', encoding='utf-8')
print('beegeek', file=f)
# В этом случае текст так же будет записан в файл, а не выведен на экран.

# «sys.stdout» это переменная, которая хранит в себе <ссылку> на адрес области памяти, где хранится выходная информация, посылаемая функцией print например.
# Когда мы пишем temp = sys.stdout, то сохраняем <ссылку> (адрес области памяти) в переменную temp, чтобы потом,
# после того как мы изменили значение переменной sys.stdout = open('log.txt', 'w') мы снова смогли обратно присвоить переменной sys.stdout эту ссылку (sys.stdout = temp).
# А так бы ссылка «потерялась» и вернуть переменной sys.stdout прежнее состояние похожим образом не получилось бы.