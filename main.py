# == Типы данных date и time. ==

# == Модуль datetime ==
# Модуль datetime состоит из нескольких типов данных. Благодаря их наличию программист получает доступ ко многим полезным методам:
    # получение текущих системных даты и времени
    # вычисление разницы между датами и другие арифметические операции над ними
    # сравнение даты и времени
    # форматированный вывод информации о дате и времени
# Модуль datetime включает в себя несколько разных типов данных, каждый из которых обладает собственными методами и атрибутами, а также служит для определенных целей.
# date - представляет собой информацию о дате, исключая данные о времени, на основе григорианского календаря
# time - представляет собой информацию о времени, полностью исключая сведения о дате
# datetime - содержит информацию о времени и дате, основываясь на данных из григорианского календаря
# timedelta	- описывает определенный период во времени, который находится между двумя различными моментами
# tzinfo - представляет различные сведения о часовом поясе
# timezone - описывает время, руководствуясь стандартом UTC




# == Тип данных date ==
# Тип данных (класс) date используется для представления данных о дате и включает информацию о годе, месяце и дне.
# Чтобы иметь возможность использовать этот тип данных, необходимо предварительно импортировать его из модуля datetime:
from datetime import date
# При создании новой даты (тип данных date) нужно указать год, месяц и день.

my_date = date(1992, 10, 6) # тип date: год + месяц + день
print(my_date)          # 1992-10-06
print(type(my_date))    # <class 'datetime.date'>
print()

# Конструктор типа date сначала принимает год, затем месяц, а уже потом день.
# Мы также можем использовать именованные аргументы, нарушая указанный порядок: date(day=6, month=10, year=1992).
# Указывая аргументы day, month, year, не следует забывать про ограничения. К примеру, нельзя указать значение day, большее 31, или значение month, большее 12.
# Иногда приходится работать не только с общими сведениями о дате, но и с отдельными ее составляющими, такими как год, месяц или день. Получить доступ к ним можно с помощью атрибутов:
    # year — год даты
    # month — месяц даты
    # day — день даты

my_date = date(1992, 10, 6)
print('Год =', my_date.year)    # Год = 1992
print('Месяц =', my_date.month) # Месяц = 10
print('День =', my_date.day)    # День = 6

# Если необходимо получить информацию о текущей дате на компьютере, на котором выполняется программа, то используется встроенный метод today().
creation_date = date.today()
print(creation_date)

# С помощью встроенного метода weekday() можно определить день недели (нумерация начинается с 0):
# 0 = понедельник
# 1 = вторник
# 2 = среда
# 3 = четверг
# 4 = пятница
# 5 = суббота
# 6 = воскресенье

date1 = date(2022, 10, 15)
date2 = date(1999, 12, 26)
print(date1.weekday())  # 5 суббота
print(date2.weekday())  # 6 воскресенье

# Если требуется определить день недели с нумерацией, начиная с 1, то используется метод isoweekday().
date1 = date(2022, 10, 15)
date2 = date(1999, 12, 26)
print(date1.isoweekday())   # 6 суббота
print(date2.isoweekday())   # 7 воскресенье

# Для получения минимально и максимально возможных дат (в рамках типа данных date) используются атрибуты min и max.
print(date.min) # 0001-01-01
print(date.max) # 9999-12-31
print()

# Методы fromordinal() и toordinal() позволяют создать дату из номера дня, начиная с 0001-01-01, и наоборот — преобразовать дату в номер дня.
date1 = date.fromordinal(365)   # дата, соответствующая номеру дня 365
date2 = date(1999, 12, 26)
print(date1)
print(date2.toordinal())    # номер дня, соответствующий дате 1999-12-26
# 0001-12-31
# 730114
print()



# == Тип данных time ==
# Тип данных (класс) time используется для представления данных о времени и включает информацию о часах, минутах, секундах и микросекундах.
# Данный тип данных полностью игнорирует информацию о дате.
# Микросекунда (мкс) — единица времени, равная одной миллионной доле секунды (10^−6 с).
# При создании времени (тип данных time) нужно указать часы, минуты, секунды и микросекунды.
from datetime import time

my_time = time(11, 20, 54, 1234)    # тип time: часы + минуты + секунды + микросекунды
print(my_time)          # 11:20:54.001234
print(type(my_time))    # <class 'datetime.time'>

# Конструктор типа time сначала принимает часы, затем минуты, секунды, а уже потом микросекунды.
# Мы можем использовать именованные аргументы (hour, minute, second, microsecond), нарушая указанный порядок.
# Указывая аргументы hour, minute, second, microsecond, не следует забывать про ограничения.
# К примеру, нельзя указать значение hour, большее 23, или значение second, большее 59.

# В отличие от дат (тип данных date), чтобы создать объект типа time, необязательно указывать все его атрибуты в конструкторе.
# Недостающие данные о времени автоматически заполняются нулями.
from datetime import time

time1 = time(11, 20, 54, 1234)
time2 = time(11, 20, 54)
time3 = time(11, 20)
time4 = time(11)
time5 = time()
time6 = time(minute=23, second=56)
print(time1, time2, time3, time4, time5, sep='\n')
print(time6)
# 11:20:54.001234
# 11:20:54
# 11:20:00
# 11:00:00
# 00:00:00
# 00:23:56

# Так же, как и при работе с типом данных date, пользуясь типом time, можно получать доступ к отдельным значениям созданного времени: часам, минутам, секундам и микросекундам.
# Получить доступ к ним можно с помощью атрибутов:
    # hour — часы времени
    # minute — минуты времени
    # second — секунды времени
    # microsecond — микросекунды времени

my_time = time(11, 20, 54, 1234)
print('Часы =', my_time.hour)
print('Минуты =', my_time.minute)
print('Секунды =', my_time.second)
print('Микросекунды =', my_time.microsecond)
print()
# Часы = 11
# Минуты = 20
# Секунды = 54
# Микросекунды = 1234




# == Сравнение дат и времени ==
# Даты (тип date) и время (тип time) можно сравнивать с помощью операторов ==, !=, <, >, <= и >=.
from datetime import date, time

date1 = date(2022, 10, 15)
date2 = date(1999, 12, 26)
time1 = time(13, 10, 5)
time2 = time(21, 32, 59)

print(date1 < date2)    # False
print(time1 < time2)    # True
print()




# == Встроенные функции str() и repr() ==
# На практике часто используются две встроенные функции str() и repr(). С их помощью можно получить строковое представление объекта.
# Встроенная функция str() возвращает объект в неформальном (понятном человеку) строковом представлении.
from datetime import date, time

my_date = date(2021, 12, 31)
my_time = time(11, 20, 54)
print(my_date)  # 2021-12-31
print(my_time)  # 11:20:54
# По сути, мы наблюдаем результат работы функции str(), которая вызывается за кулисами и преобразует указанные объекты в читаемый для человека вид.
# Приведенный ниже код использует явный вызов функции str() и идентичен коду выше:
my_date = date(2021, 12, 31)
my_time = time(11, 20, 54)
print(str(my_date))     # 2021-12-31
print(str(my_time))     # 11:20:54

# Встроенная функция repr() возвращает объект в формальном (понятном интерпретатору) строковом представлении.
my_date = date(2021, 12, 31)
my_time = time(11, 20, 54)
print(repr(my_date))    # datetime.date(2021, 12, 31)
print(repr(my_time))    # datetime.time(11, 20, 54)
print()

# Для встроенных типов данных при печати одиночного значения объекта явно вызывать функцию str() не требуется, однако при печати списка таких объектов это необходимо.
dates = [date(2021, 12, 31), date(2019, 10, 6), date(2022, 11, 8)]   # список дат
print(dates)    # [datetime.date(2021, 12, 31), datetime.date(2019, 10, 6), datetime.date(2022, 11, 8)]

# Если мы хотим вывести содержимое списка в в удобном человеку виде, то нужно прибегнуть к распаковке:
# в этом случае функция str() будет вызываться для каждого элемента списка за кулисами.
dates = [date(2021, 12, 31), date(2019, 10, 6), date(2022, 11, 8)]
print(*dates, sep=", ")     # 2021-12-31, 2019-10-06, 2022-11-08
print()



# == Примечания ==

# Примечание 1. Типы данных date и time оба являются неизменяемыми.
# Мы можем создать множества, содержащие объекты данных типов (date и time), кроме того, они могут выступать в качестве ключей словаря.
from datetime import date

my_set = {date(2021, 12, 31), date(2019, 3, 19), date(2022, 5, 25)}   # множество
my_dict = {date(2021, 12, 31): 'Новый год', date(2030, 10, 6): 'День рождения'}    # словарь
print(my_set)   # {datetime.date(2019, 3, 19), datetime.date(2021, 12, 31), datetime.date(2022, 5, 25)}
print(my_dict)  # {datetime.date(2021, 12, 31): 'Новый год', datetime.date(2030, 10, 6): 'День рождения'}
print()

# Примечание 2. Мы можем использовать встроенные функции min(), max(), sorted() и так далее при работе с типами данных date и time.
dates = [date(2021, 12, 31), date(2025, 3, 19), date(2017, 5, 25)]
print(min(dates))   # 2017-05-25
print(max(dates))   # 2025-03-19
print(sorted(dates))    # [datetime.date(2017, 5, 25), datetime.date(2021, 12, 31), datetime.date(2025, 3, 19)]
print()

# Примечание 3. Для создания новой даты на основании уже существующей можно использовать метод replace().
# Он возвращает новую дату с переданными измененными значениями свойств year, month, day.
date1 = date(1992, 10, 6)
date2 = date1.replace(year=1995)            # заменяем год
date3 = date1.replace(month=12, day=17)     # заменяем месяц и число
print(date1)    # 1992-10-06
print(date2)    # 1995-10-06
print(date3)    # 1992-12-17
print()
# Аналогично для создания нового времени на основании уже существующего используется метод replace().

# Примечание 7. По умолчанию объекты типов date и time выводятся в формате ISO 8601:
# дата в формате ISO 8601 имеет следующий вид: YYYY-MM-DD
# время в формате ISO 8601 имеет следующий вид: HH:MM:SS или HH:MM:SS.ffffff


# Получить текущее время:
from datetime import date, time, datetime

time_now = datetime.now()
print(time_now)     # получаем такой вид -> 2026-02-01 00:01:46.639200
print(str(time_now)[11:])   # вот так можно получить именно время. Вывод -> 00:01:46.639200
print(time(time_now.hour, time_now.minute, time_now.second))    # или вот так -> 00:01:46